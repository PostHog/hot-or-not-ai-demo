{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 73, "column": 0}, "map": {"version":3,"sources":["file:///Users/landondepasquale/hot-or-not-leads/lib/auth.ts"],"sourcesContent":["import { SignJWT, jwtVerify } from 'jose';\nimport { cookies } from 'next/headers';\nimport type { Session, User } from './types';\n\nconst secretKey = new TextEncoder().encode(\n  process.env.AUTH_SECRET || 'hot-or-not-leads-secret-key-2002'\n);\n\n// Mock user database - in production this would be a real database\nconst users: User[] = [\n  {\n    id: '1',\n    email: 'demo@hotornot.com',\n    name: 'Demo User',\n    passwordHash: '$2a$10$m9SF5L1FFt/5kBW0DjDh/uDho4SJsjbJ0j5hUaB2minPRqf9M3YOC', // password: demo123\n  },\n];\n\n// Anonymous session for non-logged-in users\nexport function getAnonymousSession(): Session {\n  return {\n    userId: 'anonymous',\n    email: '',\n    name: 'Guest',\n  };\n}\n\nexport async function getSessionOrAnonymous(): Promise<Session> {\n  const session = await getSession();\n  return session || getAnonymousSession();\n}\n\nexport async function hashPassword(password: string): Promise<string> {\n  const bcrypt = await import('bcryptjs');\n  return bcrypt.hash(password, 10);\n}\n\nexport async function verifyPassword(password: string, hash: string): Promise<boolean> {\n  const bcrypt = await import('bcryptjs');\n  return bcrypt.compare(password, hash);\n}\n\nexport async function createSession(user: Omit<User, 'passwordHash'>): Promise<string> {\n  const session: Session = {\n    userId: user.id,\n    email: user.email,\n    name: user.name,\n  };\n\n  const token = await new SignJWT(session as unknown as Record<string, unknown>)\n    .setProtectedHeader({ alg: 'HS256' })\n    .setExpirationTime('7d')\n    .sign(secretKey);\n\n  return token;\n}\n\nexport async function getSession(): Promise<Session | null> {\n  const cookieStore = await cookies();\n  const token = cookieStore.get('session')?.value;\n\n  if (!token) return null;\n\n  try {\n    const { payload } = await jwtVerify(token, secretKey);\n    return payload as unknown as Session;\n  } catch {\n    return null;\n  }\n}\n\nexport async function login(email: string, password: string): Promise<{ success: boolean; error?: string }> {\n  const user = users.find((u) => u.email === email);\n\n  if (!user) {\n    return { success: false, error: 'Invalid email or password' };\n  }\n\n  const valid = await verifyPassword(password, user.passwordHash);\n  if (!valid) {\n    return { success: false, error: 'Invalid email or password' };\n  }\n\n  const token = await createSession({ id: user.id, email: user.email, name: user.name });\n  const cookieStore = await cookies();\n  cookieStore.set('session', token, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'lax',\n    maxAge: 60 * 60 * 24 * 7, // 7 days\n  });\n\n  return { success: true };\n}\n\nexport async function signup(email: string, password: string, name: string): Promise<{ success: boolean; error?: string }> {\n  const existing = users.find((u) => u.email === email);\n  if (existing) {\n    return { success: false, error: 'Email already registered' };\n  }\n\n  const passwordHash = await hashPassword(password);\n  const newUser: User = {\n    id: String(users.length + 1),\n    email,\n    name,\n    passwordHash,\n  };\n  users.push(newUser);\n\n  const token = await createSession({ id: newUser.id, email: newUser.email, name: newUser.name });\n  const cookieStore = await cookies();\n  cookieStore.set('session', token, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === 'production',\n    sameSite: 'lax',\n    maxAge: 60 * 60 * 24 * 7,\n  });\n\n  return { success: true };\n}\n\nexport async function logout(): Promise<void> {\n  const cookieStore = await cookies();\n  cookieStore.delete('session');\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AACA;;;AAGA,MAAM,YAAY,IAAI,cAAc,MAAM,CACxC,QAAQ,GAAG,CAAC,WAAW,IAAI;AAG7B,mEAAmE;AACnE,MAAM,QAAgB;IACpB;QACE,IAAI;QACJ,OAAO;QACP,MAAM;QACN,cAAc;IAChB;CACD;AAGM,SAAS;IACd,OAAO;QACL,QAAQ;QACR,OAAO;QACP,MAAM;IACR;AACF;AAEO,eAAe;IACpB,MAAM,UAAU,MAAM;IACtB,OAAO,WAAW;AACpB;AAEO,eAAe,aAAa,QAAgB;IACjD,MAAM,SAAS;IACf,OAAO,OAAO,IAAI,CAAC,UAAU;AAC/B;AAEO,eAAe,eAAe,QAAgB,EAAE,IAAY;IACjE,MAAM,SAAS;IACf,OAAO,OAAO,OAAO,CAAC,UAAU;AAClC;AAEO,eAAe,cAAc,IAAgC;IAClE,MAAM,UAAmB;QACvB,QAAQ,KAAK,EAAE;QACf,OAAO,KAAK,KAAK;QACjB,MAAM,KAAK,IAAI;IACjB;IAEA,MAAM,QAAQ,MAAM,IAAI,uKAAO,CAAC,SAC7B,kBAAkB,CAAC;QAAE,KAAK;IAAQ,GAClC,iBAAiB,CAAC,MAClB,IAAI,CAAC;IAER,OAAO;AACT;AAEO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,MAAM,QAAQ,YAAY,GAAG,CAAC,YAAY;IAE1C,IAAI,CAAC,OAAO,OAAO;IAEnB,IAAI;QACF,MAAM,EAAE,OAAO,EAAE,GAAG,MAAM,IAAA,2KAAS,EAAC,OAAO;QAC3C,OAAO;IACT,EAAE,OAAM;QACN,OAAO;IACT;AACF;AAEO,eAAe,MAAM,KAAa,EAAE,QAAgB;IACzD,MAAM,OAAO,MAAM,IAAI,CAAC,CAAC,IAAM,EAAE,KAAK,KAAK;IAE3C,IAAI,CAAC,MAAM;QACT,OAAO;YAAE,SAAS;YAAO,OAAO;QAA4B;IAC9D;IAEA,MAAM,QAAQ,MAAM,eAAe,UAAU,KAAK,YAAY;IAC9D,IAAI,CAAC,OAAO;QACV,OAAO;YAAE,SAAS;YAAO,OAAO;QAA4B;IAC9D;IAEA,MAAM,QAAQ,MAAM,cAAc;QAAE,IAAI,KAAK,EAAE;QAAE,OAAO,KAAK,KAAK;QAAE,MAAM,KAAK,IAAI;IAAC;IACpF,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,YAAY,GAAG,CAAC,WAAW,OAAO;QAChC,UAAU;QACV,QAAQ,oDAAyB;QACjC,UAAU;QACV,QAAQ,KAAK,KAAK,KAAK;IACzB;IAEA,OAAO;QAAE,SAAS;IAAK;AACzB;AAEO,eAAe,OAAO,KAAa,EAAE,QAAgB,EAAE,IAAY;IACxE,MAAM,WAAW,MAAM,IAAI,CAAC,CAAC,IAAM,EAAE,KAAK,KAAK;IAC/C,IAAI,UAAU;QACZ,OAAO;YAAE,SAAS;YAAO,OAAO;QAA2B;IAC7D;IAEA,MAAM,eAAe,MAAM,aAAa;IACxC,MAAM,UAAgB;QACpB,IAAI,OAAO,MAAM,MAAM,GAAG;QAC1B;QACA;QACA;IACF;IACA,MAAM,IAAI,CAAC;IAEX,MAAM,QAAQ,MAAM,cAAc;QAAE,IAAI,QAAQ,EAAE;QAAE,OAAO,QAAQ,KAAK;QAAE,MAAM,QAAQ,IAAI;IAAC;IAC7F,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,YAAY,GAAG,CAAC,WAAW,OAAO;QAChC,UAAU;QACV,QAAQ,oDAAyB;QACjC,UAAU;QACV,QAAQ,KAAK,KAAK,KAAK;IACzB;IAEA,OAAO;QAAE,SAAS;IAAK;AACzB;AAEO,eAAe;IACpB,MAAM,cAAc,MAAM,IAAA,4IAAO;IACjC,YAAY,MAAM,CAAC;AACrB","debugId":null}},
    {"offset": {"line": 220, "column": 0}, "map": {"version":3,"sources":["file:///Users/landondepasquale/hot-or-not-leads/app/api/auth/login/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { login } from '@/lib/auth';\n\nexport async function POST(request: Request) {\n  try {\n    const { email, password } = await request.json();\n\n    if (!email || !password) {\n      return NextResponse.json(\n        { error: 'Email and password are required' },\n        { status: 400 }\n      );\n    }\n\n    const result = await login(email, password);\n\n    if (!result.success) {\n      return NextResponse.json({ error: result.error }, { status: 401 });\n    }\n\n    return NextResponse.json({ success: true });\n  } catch {\n    return NextResponse.json({ error: 'An error occurred' }, { status: 500 });\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,MAAM,EAAE,KAAK,EAAE,QAAQ,EAAE,GAAG,MAAM,QAAQ,IAAI;QAE9C,IAAI,CAAC,SAAS,CAAC,UAAU;YACvB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAkC,GAC3C;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,SAAS,MAAM,IAAA,sHAAK,EAAC,OAAO;QAElC,IAAI,CAAC,OAAO,OAAO,EAAE;YACnB,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO,OAAO,KAAK;YAAC,GAAG;gBAAE,QAAQ;YAAI;QAClE;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,SAAS;QAAK;IAC3C,EAAE,OAAM;QACN,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAoB,GAAG;YAAE,QAAQ;QAAI;IACzE;AACF","debugId":null}}]
}